#!/usr/bin/env python

"""
Use EMCEE to do MCMC in Xspec.
Jeremy Sanders 2012

Requires Python 2.7+, numpy, scipy and emcee
"""

import sys
import argparse

import numpy as N
import emcee

import xspec_pool

def getInitialParameters(parameters, nwalkers):
    """Construct list of initial parameter values for each walker."""
    p0 = []
    for walker in xrange(nwalkers):
        pwalker = []
        # for each walker, use initial parameters based on parameter
        # and delta parameter
        for par in parameters:
            width = par['val_delta']
            swidth = par['val_sigma']*0.1
            if swidth > 0 and swidth < width:
                # use sigma if delta is badly adjusted
                width = swidth

            v = N.random.normal(par['val_init'], width)
            # clip to hard range
            v = N.clip(v, par['val_hardmin'], par['val_hardmax'])
            pwalker.append(v)
        p0.append( N.array(pwalker) )
    return p0

def doMCMC(xcm, nwalkers=100, nburn=100, niters=1000, systems = ['localhost'],
           outchain = 'out.dat', debug=False):
    """Do the actual MCMC process."""

    # pool controls xspecs and parameters
    # this should be a multiprocessing.Pool, but we implement
    # our own pool as it is much more reliable
    pool = xspec_pool.XspecPool(xcm, systems, debug=debug)

    p0 = getInitialParameters(pool.parameters, nwalkers)

    # sample the mcmc
    sampler = emcee.EnsembleSampler(nwalkers, len(p0[0]), None, pool=pool)

    if nburn > 0:
        # burn in
        print "Burn in period started"
        pos, prob, state = sampler.run_mcmc(p0, nburn)
        sampler.reset()
        print "Burn in period finished"
    else:
        # no burn in
        state = None
        pos = p0

    # run for real
    try:
        sampler.run_mcmc(pos, niters, rstate0=state)
    except KeyboardInterrupt:
        print "Ctrl+C pressed. Saving state of chain."
        return sampler

    writeXSpecChain(outchain, sampler, pool.parlist, pool.paridxs)

    return sampler

def writeXSpecChain(filename, sampler, params, paridxs):
    """Write an xspec text chain file."""

    chain = sampler.chain
    lnprob = sampler.lnprobability

    with open(filename, 'w') as f:
        f.write('! Markov chain file generated by xspec "chain" command.\n')
        f.write('!    Do not modify, else file may not reload properly.\n')
        length = chain.shape[0] * chain.shape[1]
        width = chain.shape[2]
        f.write('!Length: %i  Width: %i\n' % (length, width+1))

        # header for contents of file
        hdr = []
        for idx in paridxs:
            hdr.append("%i %s %s" % (
                    idx, params[idx-1]['name'],
                    "0" if params[idx-1]['unit'] == ""
                    else params[idx-1]['unit']))
        hdr.append("Chi-Squared")
        f.write('!%s\n' % ' '.join(hdr))

        for w, walker in enumerate(N.dstack((chain, N.expand_dims(-lnprob*2, 2)))):
            #f.write('! walker %i\n' % i)
            for line in walker:
                fmt = '\t'.join(['%g']*len(line))
                f.write( fmt % tuple(line) + '\n' )

def writeNpz(filename, sampler):
    """Write output NPZ file."""

    print "Writing", filename

    chain = sampler.chain
    lnprob = sampler.lnprobability
    acceptfrac = sampler.acceptance_fraction
    i = sampler.iterations

    if i < chain.shape[1]:
        print "Truncating chain at first", i-1, "iterations"
        chain = N.array(chain)[:, :i-1, :]
        lnprob = N.array(lnprob)[:, :i-1]

    N.savez( filename,
             chain = chain,
             lnprobability = lnprob,
             acceptance_fraction = acceptfrac,
             )

def main():
    """Main program."""

    p = argparse.ArgumentParser(
        description="Xspec MCMC with EMCEE. Jeremy Sanders 2012.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    p.add_argument("xcm", metavar="XCM",
                   help="Input XCM file")
    p.add_argument("--niters", metavar="N", type=int, default=5000,
                   help="Number of iterations")
    p.add_argument("--nburn", metavar="N", type=int, default=500,
                   help="Number of burn iterations")
    p.add_argument("--nwalkers", metavar="N", type=int, default=50,
                   help="Number of walkers")
    p.add_argument("--systems", default="localhost", metavar="LIST",
                   help="Space separated list of systems to run on")
    p.add_argument("--output-npz", default="emcee.npz", metavar="FILE",
                   help="Output NPZ file")
    p.add_argument("--output-chain", default="emcee.chain", metavar="FILE",
                   help="Output text file")
    p.add_argument("--debug", action="store_true", default=False,
                   help="Create xspec log files")

    args = p.parse_args()

    print "Starting MCMC"
    sampler = doMCMC( args.xcm,
                      systems = args.systems.split(),
                      nwalkers = args.nwalkers,
                      nburn = args.nburn,
                      niters = args.niters,
                      outchain = args.output_chain,
                      debug = args.debug,
                      )

    writeNpz(args.output_npz, sampler)

    print "Done"

if __name__ == '__main__':
    main()
